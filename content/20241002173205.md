---
aliases:
  - React Tips
date: 2024-10-02
date modified: 2024-10-03
title: React Tips
---

# React Tips

## Context

When creating a context, use `null` instead of an object with empty values that matches the shape of the context. In the hook that consumes the context, throw an error if the context is null. This allows the context to fail loudly when set up is incorrect.

```tsx
type BookContextType = {
  book: { name: string };
  changeName: (_: name) => void;
}

// null! here for type assertion
const BookContext = createContext<BookContextType>(null!)

// hook
const useBook = () => {
  const value = useContext(BookContext)

  if (!value) throw new Error('useBook hook used without BookContext!')
  
  return value
}

// component
const BookForm = () => {
  const { book, changeName } = useBook()

	return (
	  <BookContext.Provider value={{ ... }}>
	    <h1>Book: {book.name}</h1>
	    <input value={book.name} onChange={(e) => changeName(e.target.value)} />
	  </div>
	)
}
```

## Re-rendering

### Something that Does NOT Depend on the Context Changes when the Context Changes

This is because that "something" is a child **inside** a parent component, and the context is the dependency of the parent component. A change of context will cause the parent component to re-render which then re-render that "something".

One way to think about is to think about the compiled JS code.

| Case                              | JSX code                                         | JS code                                                         |
| --------------------------------- | ------------------------------------------------ | --------------------------------------------------------------- |
| Child is inside Parent definition | `<MyComponent propA={1} />`                      | `React.createElement(MyComponent, { propA: 1 })`                |
| Child is passed as children       | `<MyComponent propA={1}><Child /></MyComponent>` | `React.createElement(MyComponent, { propA: 1, children: ... })` |
